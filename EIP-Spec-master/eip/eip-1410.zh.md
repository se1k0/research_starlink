---

eip: ERC-1410
title: 部分可替代代币标准（ERC-1400 安全代币标准的一部分）
author: Adam Dossa (@adamdossa), Pablo Ruiz (@pabloruiz55), Fabian Vogelsteller (@frozeman), Stephane Gosselin (@thegostep)
discussions-to: #1411
status: Draft
type: Standards Track
category: ERC
created: 2018-09-13
require: ERC-1066 (#1066)

---

## 简单摘要

一种用于将某所有者的代币组织为一组分区（partitions）的标准接口。

## 摘要

本标准隶属于与安全代币相关的 ERC-1400（#1411）标准集合之下。

描述一种接口，支持将所有者的代币分组到若干分区中，每个分区由一个标识键与一个余额表示。

代币在分区粒度上进行操作，但同时也跟踪有关代币总供给与所有者整体余额的数据。

该标准可与 ERC-20（#20）或 ERC-777（#777）结合，为代币合约在代币持有人余额的不同分区上的行为提供更细粒度的透明度。

## 动机

能够将元数据与单个可替代代币关联，在构建与这些代币相关的功能时非常有用。

例如，知道某一代币的铸造时间，允许对代币持有人余额的一部分实现归属（vesting）或锁定逻辑。

表示证券的代币通常要求将元数据附加到单个代币，例如与股份关联的限制。

能够将任意元数据与用户持有的代币组关联，在多种使用场景中都很有用。它可以用于代币溯源（即记录代币之前的持有人），或附加用于确定该代币任何转移限制的数据。

一般而言，代币在某些情况下可能是可替代的，但在其他情况下不是（例如游戏积分与存入的余额）。能够定义此类分组并在其上操作，同时维护有关代币整体分布的数据，对于建模此类资产非常有用。

以标准方式识别整体余额中的代币分组，有助于为代币持有人提供其余额的透明度。

## 设计原理（Rationale）

部分可替代代币允许将元数据附加到代币持有人部分余额上。这些部分余额称为分区（partitions），并由一个 `bytes32 _partition` 键索引，该键可以与链上或链下的元数据关联。

除了使用 `_partition` 键来标识该元数据的存在之外，该元数据的规范并非本标准的一部分。如果对于具有相同分区的代币持有人数据不同（例如“受限”分区对每位代币持有人可能关联不同的锁定日期），则可以将代币持有人的地址与该分区配对用作元数据键。

对于单个所有者，一个分区内的每个代币因此共享相同元数据。

代币的可替代性包含元数据信息，因此我们有：
  - 对于特定用户，给定分区内的代币是可替代的；
  - 对于特定用户，不同分区的代币可能不可替代。

注意：跨不同用户具有相同 `bytes32` 键的分区，其元数据可能因实现而异。

## 向后兼容性

本标准对 ERC-20 与 ERC-777 持中立态度。它可以轻松与任一标准结合，我们预计通常会如此。因此我们不定义标准代币视图函数（`name`、`symbol`、`decimals`）。

为了保持与 ERC-20/ ERC-777（以及其他可替代代币标准）的向后兼容，需要定义在执行 `transfer` / `send` 操作（即未显式指定分区时）使用哪个分区或哪些分区。然而这被视为实现细节（可以通过固定列表或程序确定）。一种选择是简单地遍历该代币持有人的所有 `partitionsOf`，尽管这种方法需要考虑区块 gas 上限。

## 规范

### 代币信息

#### balanceOf

聚合某代币持有人跨所有分区的余额。等同于 ERC-20/777 规范中的 `balanceOf`。

必须统计分配给代币持有人的所有分区余额之和。

``` solidity
function balanceOf(address _tokenHolder) external view returns (uint256);
```

#### balanceOfByPartition

除了通过 `balanceOf` 查询跨所有分区的总余额外，也可能需要确定特定分区的余额。

对于给定的代币持有人，跨其 `partitionsOf` 的 `balanceOfByPartition` 之和必须等于 `balanceOf`。

``` solidity
function balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns (uint256);
```

#### partitionsOf

某代币持有人的余额可能被拆分为多个分区（partitions）——该函数将返回与特定代币持有人地址关联的所有分区。

``` solidity
function partitionsOf(address _tokenHolder) external view returns (bytes32[]);
```

#### totalSupply

返回跨所有代币持有人与分区的已发行代币总量。

必须统计该合约跟踪的所有代币。

``` solidity
function totalSupply() external view returns (uint256);
```

### 代币转移

代币转移始终关联来源分区与目标分区，以及常规的数量与发送/接收地址。

例如，一个许可型代币可以使用分区元数据基于以下内容强制转移限制：
  - `_partition` 的值；
  - 与 `_partition` 值相关的任何附加数据（例如可能与 `_partition` 关联的锁定时间戳）；
  - 与代币发送者或接收者相关的任何细节（例如其身份是否已建立）；
  - 被转移代币的数量（例如是否符合任何每日或其他周期性的数量限制）；
  - `_data` 参数允许调用者提交与转移相关的任何其他授权或细节（例如由获授权实体签署的数据，该实体被允许对该转移进行授权）。

其他用例包括通过将先前持有人与目标分区关联来跟踪代币溯源。

#### transferByPartition

如果由于任何原因代币转移不成功，该函数必须抛出异常（throw/revert）。

当从特定分区转移代币时，能够在链上（即不仅仅通过触发事件）知道这些代币的目标分区是有用的。目标分区由该函数的实现决定，并根据用例而异。

该函数必须返回接收方的 `bytes32 _partition`。

`bytes _data` 允许在转移时提交任意数据，由代币合约解释或记录。该数据可能是授权该转移的签名数据（例如动态白名单），或为代币合约确定接收方分区提供输入。

该函数必须在成功的转移时发出 `TransferByPartition` 事件。

``` solidity
function transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes _data) external returns (bytes32);
```

#### operatorTransferByPartition

允许操作员在指定分区内，代表代币持有人转移安全代币。

如果由缺乏 `isOperatorForPartition` 或 `isOperatorFor` 所定义的相应批准的地址调用，该函数必须回退（revert）。

该函数在成功的代币转移时必须发出 `TransferByPartition` 事件，并包含操作员地址。

其返回数据与 `transferByPartition` 的解释保持一致。

``` solidity
function operatorTransferByPartition(bytes32 _partition, address _from, address _to, uint256 _value, bytes _data, bytes _operatorData) external returns (bytes32);
```

#### canTransferByPartition

部分可替代代币的转移可能由于多种原因失败，既可能与代币持有人的部分余额有关，也可能与被转移分区相关的规则有关。

本标准提供一个链上函数以确定某次转移是否会成功，并在转移无效时返回指示原因的详细信息。

这些规则既可以使用智能合约与链上数据定义，也可以依赖通过 `transferByPartition` 函数传入的 `_data`（例如由转移代理签名的消息，证明该次转移的有效性）。

该函数将返回一个遵循 EIP-1066 标准的以太坊状态码（ESC），以及一个可以用于定义具有更多细节的应用特定原因码的附加 `bytes32` 参数（例如使该转移操作无效的转移限制规则）。

它还会以与 `transferByPartition` 类似的方式返回被转移代币的目标分区。

``` solidity
function canTransferByPartition(address _from, address _to, bytes32 _partition, uint256 _value, bytes _data) external view returns (byte, bytes32, bytes32);
```

### 操作员

个体代币持有人可以为所有分区或特定分区授权操作员。

  - 针对特定代币持有人的所有分区（`authorizeOperator`、`revokeOperator`、`isOperatorFor`）
  - 针对特定代币持有人的特定分区（`authorizeOperatorByPartition`、`revokeOperatorByPartition`、`isOperatorForPartition`）

#### authorizeOperator

允许代币持有人为其跨所有分区的代币设置一个操作员。

必须为 `msg.sender` 的所有分区授权一个操作员。

每次调用该函数都必须发出 `AuthorizedOperator` 事件。

``` solidity
function authorizeOperator(address _operator) external;
```

#### revokeOperator

允许代币持有人撤销其跨所有分区的代币操作员。

注意——操作员可能仍会通过 `authorizeOperatorByPartition` 对该代币持有人与某些分区保留授权。

必须撤销之前为 `msg.sender` 的所有分区授予的操作员授权。

每次调用该函数都必须发出 `RevokedOperator` 事件。

``` solidity
function revokeOperator(address _operator) external;
```

#### isOperatorFor

返回某一地址是否为给定代币持有人与全部分区的操作员。

如果该地址在上述任意类别下是操作员，则应返回 TRUE。

必须查询 `_operator` 是否是 `_tokenHolder` 的所有分区的操作员。

``` solidity
function isOperatorFor(address _operator, address _tokenHolder) external view returns (bool);
```

#### authorizeOperatorByPartition

允许代币持有人为其某一特定分区的代币设置一个操作员。

每次调用该函数都必须发出 `AuthorizedOperatorByPartition` 事件。

``` solidity
function authorizeOperatorByPartition(bytes32 _partition, address _operator) external;
```

#### revokeOperatorByPartition

允许代币持有人撤销其某一特定分区的代币操作员。

注意——操作员可能仍会通过 `defaultOperatorsByPartition` 或 `defaultOperators` 对该代币持有人与该分区保留授权。

每次调用该函数都必须发出 `RevokedOperatorByPartition` 事件。

``` solidity
function revokeOperatorByPartition(bytes32 _partition, address _operator) external;
```

#### isOperatorForPartition

返回某一地址是否为给定代币持有人与分区的操作员。

如果该地址在上述任意类别下是操作员，则应返回 TRUE。

``` solidity
function isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool);
```

## 接口

``` solidity
/// @title ERC-1410 部分可替代代币标准
/// @dev 参见 https://github.com/SecurityTokenStandard/EIP-Spec

interface IERC1410 {

    // 代币信息
    function balanceOf(address _tokenHolder) external view returns (uint256);
    function balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns (uint256);
    function partitionsOf(address _tokenHolder) external view returns (bytes32[]);
    function totalSupply() external view returns (uint256);

    // 代币转移
    function transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes _data) external returns (bytes32);
    function operatorTransferByPartition(bytes32 _partition, address _from, address _to, uint256 _value, bytes _data, bytes _operatorData) external returns (bytes32);
    function canTransferByPartition(address _from, address _to, bytes32 _partition, uint256 _value, bytes _data) external view returns (byte, bytes32, bytes32);    

    // 操作员信息
    function isOperator(address _operator, address _tokenHolder) external view returns (bool);
    function isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool);

    // 操作员管理
    function authorizeOperator(address _operator) external;
    function revokeOperator(address _operator) external;
    function authorizeOperatorByPartition(bytes32 _partition, address _operator) external;
    function revokeOperatorByPartition(bytes32 _partition, address _operator) external;

    // 发行 / 赎回
    function issueByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes _data) external;
    function redeemByPartition(bytes32 _partition, uint256 _value, bytes _data) external;
    function operatorRedeemByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes _operatorData) external;

    // 转移事件
    event TransferByPartition(
        bytes32 indexed _fromPartition,
        address _operator,
        address indexed _from,
        address indexed _to,
        uint256 _value,
        bytes _data,
        bytes _operatorData
    );

    // 操作员事件
    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);
    event RevokedOperator(address indexed operator, address indexed tokenHolder);
    event AuthorizedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);
    event RevokedOperatorByPartition(bytes32 indexed partition, address indexed operator, address indexed tokenHolder);

    // 发行 / 赎回事件
    event IssuedByPartition(bytes32 indexed partition, address indexed operator, address indexed to, uint256 value, bytes data, bytes operatorData);
    event RedeemedByPartition(bytes32 indexed partition, address indexed operator, address indexed from, uint256 value, bytes operatorData);

}
```

