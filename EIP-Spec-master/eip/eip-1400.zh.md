---

eip: ERC-1400
title: 安全代币标准
author: Adam Dossa (@adamdossa), Pablo Ruiz (@pabloruiz55), Fabian Vogelsteller (@frozeman), Stephane Gosselin (@thegostep)
discussions-to: #1411
status: Draft
type: Standards Track
category: ERC
created: 2018-09-09
require: ERC-1410 (#1410), ERC-1594 (#1594), ERC-1644 (#1644), ERC-1643 (#1643), ERC-20 (#20), ERC-1066 (#1066)

---

## 简单摘要

表示一组以太坊上安全代币的标准库。

整体上提供一套标准化接口，用于发行/赎回安全代币、管理其所有权与转移限制，并为代币持有人提供透明度，说明其代币余额的不同子集在转移限制、权利与义务方面的行为。

## 摘要

标准应向后兼容 ERC-20（#20），并可轻松扩展以兼容 ERC-777（#777）。

ERC-1410（#1410）：差异化所有权/透明限制
ERC-1594（#1594）：链上限制检查与错误信号、为转移限制与发行/赎回语义注入链下数据
ERC-1643（#1643）：文档/标注管理
ERC-1644（#1644）：控制者操作（强制转移）

## 动机

通过指定标准接口来加速在以太坊区块链上发行与管理证券，使所有相关方都可以对安全代币进行操作与查询。

综合来看，这些安全代币标准提供文档管理、错误信号、门卫（操作员）访问控制、链下数据注入、发行/赎回语义，并暴露代币持有人余额的部分可替代子集。

## 要求

将证券的发行、交易与生命周期事件迁移到公共账本上，需要一种在链上对证券、其所有权及其属性进行建模的标准方式。

以下需求是在与安全代币生态系统内的相关方讨论后汇编而成：

- 必须有一个标准接口以查询转移是否会成功，并返回失败原因。
- 必须能够为法律行动或资金找回执行强制转移。
- 必须为发行与赎回发出标准事件。
- 必须能够将元数据附加到代币持有人余额的子集，例如特殊股东权利或用于转移限制的数据。
- 必须能够在转移时基于链下数据、链上数据以及转移参数修改元数据。
- 必须支持查询与订阅该证券的任何相关文档的更新。
- 可以要求在转移交易中传递签名数据，以便在链上进行验证。
- 不应限制可表示的资产类别在不同司法辖区的范围。
- 必须与 ERC-20 兼容。
- 可以与 ERC-777 兼容。

## 设计原理（Rationale）

### ERC-1594：核心安全代币标准

与仅需发送方拥有足够余额的效用代币不同，证券的转移可能因多种原因失败。

这些条件可能与被转移证券的元数据相关（例如是否受锁定期约束）、与证券发送者和接收者的身份相关（例如是否完成 KYC 流程、是否为合格投资者或发行方关联人），或与特定转移无关而是在代币层面设定（例如代币合约强制最大投资者数量或单一投资者持有比例上限）。

对于 ERC-20 代币，`balanceOf` 与 `allowance` 函数提供了一种在执行转移前检查转移是否可能成功的方法，可在链上与链下执行。

对于表示证券的代币，本标准引入 `canTransfer` / `canTransferByPartition` 函数，使在失败原因更复杂时可更通用地实现上述检查；并将整个转移（即包括与转移一同发送的任何数据及证券接收者）作为函数的输入。

为提供较“真/假”更丰富的结果，返回一个字节的返回码。这使我们能够给出转移失败的原因，或至少是失败的原因类别。文档查询与转移成功预期能力包含在安全代币部分。

为支持向转移函数注入链下数据，扩展了转移函数为 `transferWithData` / `transferFromWithData`，它们可以选择性地接受额外的 `bytes _data` 参数。

### ERC-1410：部分可替代代币

存在许多类型的证券，尽管代表相同的基础资产，但需要与之绑定差异化数据。

这些附加元数据在隐含上使此类证券为不可替代，但在实践中，这些数据通常应用于证券的一个子集而非单个证券。能够将代币持有人的余额划分为多个分区（partition），每个分区具有独立元数据，这一点在“部分可替代代币”章节中予以解决。

例如，某代币持有人的余额可以分为两部分：一次发行期间发行的代币与通过二级市场交易获得的代币。

安全代币合约可以引用这些元数据，以便应用附加逻辑来判定转移是否合法，并确定一旦转移至接收者余额后应与代币关联的元数据。

或者，安全代币也可以仅使用该机制向投资者透明展示其代币的不同子集在转移限制方面的行为。在这种情况下，余额可以通过程序计算确定。

### ERC-1643：文档管理标准

安全代币通常伴随相关文档。这可能是发行说明书、法律标注等。

能够设置/移除与检索这些文档，并对这些操作发出事件，使投资者能够及时了解其投资相关文档的最新情况。

本标准不提供任何在链上表明投资者已阅读或同意这些文档的方式。

### ERC-1644：控制者代币操作标准

由于安全代币受到监管与法律监督（其细节视司法辖区、监管框架与标的资产而定），在许多情形下发行方（或由发行方委托、作为控制者的实体，如监管机构或过户代理）需要保留在地址之间强制转移代币的能力。

这些控制者转移应透明（发出标记为强制转移的事件），且代币合约自身应明确是否可能允许此类操作。

可能需要该能力的示例包括：撤销欺诈交易、解决私钥丢失与回应法院命令。

## 规范

本标准不指定任何额外函数，而是引用 ERC-1410（#1410）、ERC-1594（#1594）、ERC-1643（#1643）与 ERC-1655（#1644）作为底层安全代币标准库，每个标准涵盖安全代币功能的不同方面。

为组合上述两个标准，规定以下附加约束。

### operatorTransferByPartition

如果代币可被控制（`isControllable` 返回 `TRUE`），则控制者可在未被代币持有人显式授权的情况下使用 `operatorTransferByPartition`。

在此情况下，`operatorTransferByPartition` 也必须发出 ControllerTransfer 事件。

相应地，如果 `isControllable` 返回 `FALSE`，则控制者不得调用 `operatorTransferByPartition`，除非已被代币持有人显式授权。

### operatorRedeemByPartition

如果代币可被控制（`isControllable` 返回 `TRUE`），则控制者可在未被代币持有人显式授权的情况下使用 `operatorRedeemByPartition`。

在此情况下，`operatorRedeemByPartition` 也必须发出 ControllerRedemption 事件。

相应地，如果 `isControllable` 返回 `FALSE`，则控制者不得调用 `operatorRedeemByPartition`，除非已被代币持有人显式授权。

### 默认分区（Default Partitions）

为了让 `transfer` 与 `transferWithData` 能在部分可替代代币上运行，需要存在这些函数适用的默认分区的概念。关于如何确定这些分区（例如固定列表、动态确定或使用 `partitionsOf`）的细节留作实现细节，而非标准的一部分。

当在 `transfer` 或 `transferWithData` 操作中进行代币转移时，这些转移应遵守部分可替代代币的不变式，即跨所有分区的余额之和应等于代币持有人的总余额。

## 接口

``` solidity
/// @title IERC1400 安全代币标准
/// @dev 参见 https://github.com/SecurityTokenStandard/EIP-Spec

interface IERC1400 is IERC20 {

  // 文档管理
  function getDocument(bytes32 _name) external view returns (string, bytes32);
  function setDocument(bytes32 _name, string _uri, bytes32 _documentHash) external;

  // 代币信息
  function balanceOfByPartition(bytes32 _partition, address _tokenHolder) external view returns (uint256);
  function partitionsOf(address _tokenHolder) external view returns (bytes32[]);

  // 转移
  function transferWithData(address _to, uint256 _value, bytes _data) external;
  function transferFromWithData(address _from, address _to, uint256 _value, bytes _data) external;

  // 分区代币转移
  function transferByPartition(bytes32 _partition, address _to, uint256 _value, bytes _data) external returns (bytes32);
  function operatorTransferByPartition(bytes32 _partition, address _from, address _to, uint256 _value, bytes _data, bytes _operatorData) external returns (bytes32);

  // 控制者操作
  function isControllable() external view returns (bool);
  function controllerTransfer(address _from, address _to, uint256 _value, bytes _data, bytes _operatorData) external;
  function controllerRedeem(address _tokenHolder, uint256 _value, bytes _data, bytes _operatorData) external;

  // 操作员管理
  function authorizeOperator(address _operator) external;
  function revokeOperator(address _operator) external;
  function authorizeOperatorByPartition(bytes32 _partition, address _operator) external;
  function revokeOperatorByPartition(bytes32 _partition, address _operator) external;

  // 操作员信息
  function isOperator(address _operator, address _tokenHolder) external view returns (bool);
  function isOperatorForPartition(bytes32 _partition, address _operator, address _tokenHolder) external view returns (bool);

  // 代币发行
  function isIssuable() external view returns (bool);
  function issue(address _tokenHolder, uint256 _value, bytes _data) external;
  function issueByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes _data) external;

  // 代币赎回
  function redeem(uint256 _value, bytes _data) external;
  function redeemFrom(address _tokenHolder, uint256 _value, bytes _data) external;
  function redeemByPartition(bytes32 _partition, uint256 _value, bytes _data) external;
  function operatorRedeemByPartition(bytes32 _partition, address _tokenHolder, uint256 _value, bytes _operatorData) external;

  // 转移有效性
  function canTransfer(address _to, uint256 _value, bytes _data) external view returns (byte, bytes32);
  function canTransferFrom(address _from, address _to, uint256 _value, bytes _data) external view returns (byte, bytes32);
  function canTransferByPartition(address _from, address _to, bytes32 _partition, uint256 _value, bytes _data) external view returns (byte, bytes32, bytes32);    

  // 控制者事件
  event ControllerTransfer(
      address _controller,
      address indexed _from,
      address indexed _to,
      uint256 _value,
      bytes _data,
      bytes _operatorData
  );

  event ControllerRedemption(
      address _controller,
      address indexed _tokenHolder,
      uint256 _value,
      bytes _data,
      bytes _operatorData
  );

  // 文档事件
  event Document(bytes32 indexed _name, string _uri, bytes32 _documentHash);

  // 转移事件
  event TransferByPartition(
      bytes32 indexed _fromPartition,
      address _operator,
      address indexed _from,
      address indexed _to,
      uint256 _value,
      bytes _data,
      bytes _operatorData
  );

  event ChangedPartition(
      bytes32 indexed _fromPartition,
      bytes32 indexed _toPartition,
      uint256 _value
  );

  // 操作员事件
  event AuthorizedOperator(address indexed _operator, address indexed _tokenHolder);
  event RevokedOperator(address indexed _operator, address indexed _tokenHolder);
  event AuthorizedOperatorByPartition(bytes32 indexed _partition, address indexed _operator, address indexed _tokenHolder);
  event RevokedOperatorByPartition(bytes32 indexed _partition, address indexed _operator, address indexed _tokenHolder);

  // 发行/赎回事件
  event Issued(address indexed _operator, address indexed _to, uint256 _value, bytes _data);
  event Redeemed(address indexed _operator, address indexed _from, uint256 _value, bytes _data);
  event IssuedByPartition(bytes32 indexed _partition, address indexed _operator, address indexed _to, uint256 _value, bytes _data, bytes _operatorData);
  event RedeemedByPartition(bytes32 indexed _partition, address indexed _operator, address indexed _from, uint256 _value, bytes _operatorData);


}
```

### 备注

#### 链上 vs 链下转移限制

决定安全代币是否可发送的规则可能为自执行（例如限制该证券最大投资者数量的规则），也可能需要链下输入（例如交易的显式经纪人批准）。为方便后者，`transferByPartition`、`transferWithData`、`transferFromWithData`、`canTransferByPartition` 与 `canTransfer` 函数接受一个额外的 `bytes _data` 参数，该参数可由获批方签名并用于验证一次转移。

该数据的规范超出本标准范围，属于实现细节。

#### 身份

在许多司法辖区，一方是否能够接收与发送安全代币取决于该方身份的特征。例如，大多数司法辖区要求一方在有资格购买或出售特定证券之前完成某种程度的 KYC/AML 流程。此外，一方可能会被分类到某个投资者资格类别（例如合格投资者、合格购买者），其国籍也可能影响与其证券相关的限制。

有多种身份标准（例如 ERC-725（#725）、Civic、uPort）可用于捕捉一方的身份数据，也存在其他中心化管理的方法（例如维护从 KYC 角度已获批准地址的白名单）。这些身份标准的共同点是以以太坊地址为键（该地址可以是某方的钱包或身份合约），因此 `canTransfer` 函数可以使用安全代币的发送者与接收者地址作为身份代理，以决定是否满足资格要求。

除此之外，本标准不强制采用任何特定的身份方法。

#### 原因码（Reason Codes）

为改善代币持有人的体验，`canTransfer` 必须在成功或失败时基于下述 EIP-1066 应用特定状态码返回一个原因字节码。实现也可以返回任意 `bytes32` 数据，以提供原因码未涵盖的附加信息。

| Code   | 原因                                                          |
| ------ | ------------------------------------------------------------- |
| `0x50` | 	转移失败                                                    |
| `0x51` | 	转移成功                                                    |
| `0x52` | 	余额不足                                                    |
| `0x53` | 	授权额度不足                                                |
| `0x54` | 	转移已暂停（合约暂停）                                      |
| `0x55` | 	资金被锁定（锁定期）                                        |
| `0x56` | 	发送者无效                                                  |
| `0x57` | 	接收者无效                                                  |
| `0x58` | 	操作员无效（转移代理）                                      |
| `0x59` |                                                                 |
| `0x5a` |                                                                 |
| `0x5b` |                                                                 |
| `0x5a` |                                                                 |
| `0x5b` |                                                                 |
| `0x5c` |                                                                 |
| `0x5d` |                                                                 |
| `0x5e` |                                                                 |
| `0x5f` | 		代币元信息

这些代码正在讨论中：  
https://ethereum-magicians.org/t/erc-1066-ethereum-status-codes-esc/283/24

## 参考
- [EIP 1410: 部分可替代代币标准](https://github.com/ethereum/EIPs/issues/1410)
- [EIP 1594: 核心安全代币标准](https://github.com/ethereum/EIPs/issues/1594)
- [EIP 1643: 文档管理标准](https://github.com/ethereum/EIPs/issues/1643)
- [EIP 1644: 控制者代币操作标准](https://github.com/ethereum/EIPs/issues/1644)
- [EIP 草案](https://github.com/SecurityTokenStandard/EIP-Spec)

_拷贝自原始议题_：https://github.com/ethereum/EIPs/issues/1400

