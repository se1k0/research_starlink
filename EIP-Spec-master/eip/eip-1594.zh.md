---

eip: ERC-1594
title: 核心安全代币标准（ERC-1400 安全代币标准的一部分）
author: Adam Dossa (@adamdossa), Pablo Ruiz (@pabloruiz55), Fabian Vogelsteller (@frozeman), Stephane Gosselin (@thegostep)
discussions-to: #1411
status: Draft
type: Standards Track
category: ERC
created: 2018-09-09
require: ERC-20 (#20), ERC-1066 (#1066)

---

## 简单摘要

本标准隶属于与安全代币相关的 ERC-1400（#1411）标准集合。

提供一个标准，以支持将链下数据注入到转移/发行/赎回中，并能够独立于执行转移本身来检查一次转移的有效性。

## 摘要

合并了错误信号、链下数据注入以及发行/赎回语义。

本标准继承自 ERC-20（#20），如有需要可以轻松扩展以满足 ERC-777（#777）标准。

## 动机

通过指定标准接口来加速在以太坊区块链上发行与管理证券，使所有相关方都可以对安全代币进行操作与查询。

安全代币与其他代币用例有实质区别，其链下与链上参与者之间的交互更为复杂，且受到相当程度的监管审查。

在转移、发行与赎回函数旁边提供数据（例如签名授权）的能力，使安全代币能够更灵活地实施转移限制，而不必完全依赖链上白名单。

使用 ERC-1066（#1066）在无需用户实际尝试与执行一次转移的情况下，提供转移会失败的原因码，有助于改进用户体验，并可能节省因原本会失败的转移而消耗的 gas。

形式化发行与赎回语义（类似铸造/销毁）可以为代币总供给及其变动提供可见性。

## 要求

有关整个标准库的完整需求，请参阅 ERC-1400（#1411）。

以下需求是在与安全代币生态系统内的相关方讨论后汇编而成：

- 必须有一个标准接口以查询转移是否会成功，并返回失败原因。
- 必须为发行与赎回发出标准事件。
- 可以要求在转移交易中传递签名数据，以便在链上进行验证。
- 不应限制可表示的资产类别在不同司法辖区的范围。
- 必须与 ERC-20（#20）兼容。
- 可以与 ERC-777（#777）兼容。

## 设计原理（Rationale）

### 转移限制

与仅需发送方拥有足够余额的效用代币不同，证券的转移可能因多种原因失败。

这些条件可能与被转移证券的元数据相关（例如是否受锁定期约束）、与证券发送者和接收者的身份相关（例如是否完成 KYC 流程、是否为合格投资者或发行方关联人），或与特定转移无关而是在代币层面设定（例如代币合约强制最大投资者数量或单一投资者持有比例上限）。

对于 ERC-20/ ERC-777 代币，`balanceOf` 与 `allowance` 函数提供了一种在执行转移前检查转移是否可能成功的方法，可在链上与链下执行。

对于表示证券的代币，本标准引入 `canTransfer` 函数，使在失败原因更复杂时可更通用地实现上述检查；并将整个转移（即包括与转移一同发送的任何数据及证券接收者）作为函数的输入。

为支持向转移函数注入链下数据，扩展了转移函数为 `transferWithData` / `transferFromWithData`，它们可以选择性地接受额外的 `bytes _data` 参数。

为提供较“真/假”更丰富的结果，返回一个字节的返回码。这使我们能够给出转移失败的原因，或至少是失败的原因类别。文档查询与转移成功预期能力包含在安全代币部分。

## 规范

### 受限转移

#### canTransfer / canTransferFrom

证券的转移可能由于多种原因失败，例如与以下内容相关：
  - 代币发送者或接收者的身份；
  - 对被转移的特定代币设置的限制（例如某些数量的代币被锁定）；
  - 与代币整体状态相关的限制（例如投资者总数）。

本标准提供一个链上函数以确定某次转移是否会成功，并在转移无效时返回指示原因的详细信息。

这些规则既可以使用智能合约与链上数据定义，也可以依赖通过 `transferWithData` 函数传入的 `_data`（例如由转移代理签名的消息，证明该次转移的有效性）。

该函数将返回一个遵循 EIP-1066 标准的以太坊状态码（ESC），以及一个可以用于定义具有更多细节的应用特定原因码的附加 `bytes32` 参数（例如使该转移操作无效的转移限制规则）。

如果 `bytes _data` 为空，则对应于检查 `transfer`（或 `transferFrom`）请求是否会成功；如果 `bytes _data` 已填充，则对应于检查 `transferWithData`（或 `transferFromWithData`）是否会成功。

`canTransfer` 假定代币发送者为 `msg.sender`，并将通过 `transfer` 或 `transferWithData` 执行；而 `canTransferFrom` 允许指定代币发送者，并表示该转移将通过 `transferFrom` 或 `transferFromWithData` 执行。

``` solidity
function canTransfer(address _to, uint256 _value, bytes _data) external view returns (byte, bytes32);
function canTransferFrom(address _from, address _to, uint256 _value, bytes _data) external view returns (byte, bytes32);
```

#### transferWithData

转移限制可以采取多种形式，通常涉及链上规则或白名单。然而，对于许多类型的获批转移，维护一个链上的获批转移列表可能繁琐且昂贵。另一种方法是共同签署（co-signing）方式，即在代币持有人批准代币转移之外，由一个获授权实体提供签名数据以进一步验证该次转移。

`bytes _data` 允许在转移时提交任意数据，由代币合约解释或记录。该数据可能是授权该转移的签名数据（例如动态白名单），但也足够灵活以容纳其他用例。

`transferWithData` 必须发出包含该转移细节的 `Transfer` 事件。

``` solidity
function transferWithData(address _to, uint256 _value, bytes _data) external;
```

#### transferFromWithData

该函数是 `transferWithData` 的类比。

`msg.sender` 必须具有足够的 `allowance`，并且该 `allowance` 必须被 `_value` 扣减。

``` solidity
function transferFromWithData(address _from, address _to, uint256 _value, bytes _data) external;
```

### 代币发行

#### isIssuable

安全代币发行方可以指定该代币的发行已完成（即不能再铸造或发行新代币）。

如果某代币的 `isIssuable()` 返回 FALSE，则其将来必须始终返回 FALSE。

如果某代币的 `isIssuable()` 返回 FALSE，则其绝不能允许额外代币被发行。

``` solidity
function isIssuable() external view returns (bool);
```

#### issue

必须调用该函数以增加总供给。

`bytes _data` 参数可用于注入链下数据（例如签名数据），以授权或认证发行行为与已发行代币接收方。

调用时，该函数必须发出 `Issued` 事件。

``` solidity
function issue(address _tokenHolder, uint256 _value, bytes _data) external;
```

### 代币赎回

#### redeem

允许代币持有人赎回代币。

赎回的代币必须从总供给与该代币持有人的余额中扣减。代币赎回应与发送代币的行为类似，并受相同条件约束。

每次调用该函数都必须发出 `Redeemed` 事件。

与 `transferWithData` 类似，该函数具有 `bytes _data` 参数，可在代币合约中用于认证赎回行为。

``` solidity
function redeem(uint256 _value, bytes _data) external;
```

#### redeemFrom

该函数是 `redeem` 的类比。

`msg.sender` 必须具有足够的 `allowance`，并且该 `allowance` 必须被 `_value` 扣减。

每次调用该函数都必须发出 `Redeemed` 事件。

``` solidity
function redeemFrom(address _tokenHolder, uint256 _value, bytes _data) external;
```

## 接口

``` solidity
/// @title IERC1594 安全代币标准
/// @dev 参见 https://github.com/SecurityTokenStandard/EIP-Spec

interface IERC1594 is IERC20 {

    // 转移
    function transferWithData(address _to, uint256 _value, bytes _data) external;
    function transferFromWithData(address _from, address _to, uint256 _value, bytes _data) external;

    // 代币发行
    function isIssuable() external view returns (bool);
    function issue(address _tokenHolder, uint256 _value, bytes _data) external;

    // 代币赎回
    function redeem(uint256 _value, bytes _data) external;
    function redeemFrom(address _tokenHolder, uint256 _value, bytes _data) external;

    // 转移有效性
    function canTransfer(address _to, uint256 _value, bytes _data) external view returns (bool, byte, bytes32);
    function canTransferFrom(address _from, address _to, uint256 _value, bytes _data) external view returns (bool, byte, bytes32);

    // 发行/赎回事件
    event Issued(address indexed _operator, address indexed _to, uint256 _value, bytes _data);
    event Redeemed(address indexed _operator, address indexed _from, uint256 _value, bytes _data);

}
```

## 参考
- [EIP 1400: 带分区的安全代币标准](https://github.com/ethereum/EIPs/issues/1411)
- [EIP 草案](https://github.com/SecurityTokenStandard/EIP-Spec)

