---
eip: 3643
title: T-REX - 受监管交易所的代币
description: 一个机构级的安全代币标准，提供用于管理与合规转移安全代币的接口。
author: Joachim Lebrun (@Joachim-Lebrun), Tony Malghem (@TonyMalghem), Kevin Thizy (@Nakasar), Luc Falempin (@lfalempin), Adam Boudjemaa (@Aboudjem)
type: Standards Track
category: ERC
status: Stagnant
requires: 20, 1822
discussions-to: https://ethereum-magicians.org/t/eip-3643-proposition-of-the-t-rex-token-standard-for-securities/6844
created: 2021-07-09
---

## 简单摘要

T-REX 代币是 
该标准  


## 摘要

应向后兼容 [ERC-20](./eip-20.md)，并应能够与 [ERC-735](https://github.com/ethereum/EIPs/issues/735) 协作，以基于 [ERC-734](https://github.com/ethereum/EIPs/issues/734) 与 ERC-735，通过验证与[`ONCHAINID`](https://github.com/onchain-id/solidity) 关联的声明来进行验证。
本标准定义了若干接口，描述如下：
- 代币（Token）
- 身份注册表（Identity Registry）
- 身份注册表存储（Identity Registry Storage）
- 合规模块（Compliance）
- 受信发行者注册表（Trusted Issuers Registry）
- 声明主题注册表（Claim Topics Registry）

## 动机

为以太坊上发行的安全代币提供标准接口，使任何第三方都能与安全代币进行交互。
这些接口所描述的函数各不相同，使相应用户可调用一系列不同的操作，例如强制转移、冻结代币（对钱包部分或全部冻结，甚至冻结整个代币）、铸造、销毁、找回丢失的代币（若投资者丢失钱包访问权限）等。

以下需求是与希望在以太坊等 DLT 基础设施上发行证券的金融机构进行讨论后汇编而成：

- 必须与 [ERC-20](./eip-20.md) 兼容。
- 必须与链上身份识别系统（[ONCHAINID](https://github.com/onchain-id/solidity)）结合使用。
- 必须能够应用监管方或代币发行方要求的任何合规规则（关于身份资格要素或代币自身规则）。
- 必须具有在交易上链前预检转移是否会通过或失败的标准接口。
- 必须在投资者丢失私钥的情况下具备找回机制。
- 必须能够在投资者钱包上冻结代币（可部分或全部冻结）。
- 必须具备暂停代币的可能性。
- 必须能够铸造与销毁代币。
- 必须定义代理（Agent）角色与所有者（Owner，代币发行方）角色。
- 必须能够由代理钱包发起强制转移。
- 必须能够进行批量交易（节省 gas 并使所有交易在同一块内执行）。
- 必须可升级（智能合约代码应可升级且不更改代币合约地址）。

## 设计原理

### 转移限制

证券的转移可能因多种原因失败，这与通常只要求发送方具有足够余额的效用代币形成对比。
这些条件可能与投资者钱包状态、证券发送者与接收者的身份（例如是否通过 KYC、是否为合格投资者或发行方关联人）相关，或与代币层面而非特定转移有关（例如代币合约强制最大投资者数量或单一投资者持仓上限）。
对于[ERC-20](./eip-20.md) 代币，`balanceOf` 与 `allowance` 函数提供了在执行转移前检查转移大概率成功的方法，可在链上与链下执行。
对于表示证券的代币，T-REX 标准引入 `canTransfer` 函数，使在失败原因与代币合规规则相关时可更通用地实现上述检查；并引入 `isVerified` 函数以检查投资者身份的合格状态。

### 可升级性

代币合约应在不更改其链上地址的情况下可升级，因此我们决定通过 [ERC-1822](./eip-1822.md)（通用可升级代理标准，UUPS）使其具备 `proxiable` 能力。

### 身份管理

通过对链上身份的管理来确保转移的安全与合规。
- ONCHAINID
- 声明（Claim）
- 身份存储/注册表
与效用代币相比，证券的转移可能因多种原因失败。


## 规范

本标准向后兼容 [ERC-20](./eip-20.md)，因此，所有 ERC-20 函数均可在 ERC-3643 代币上调用（接口兼容）。
但函数的实现与经典 ERC-20 不同，因为 ERC-3643 是许可型代币，这意味着在每一次代币转移中都需要进行检查，以验证转移的合规性以及相关身份的资格。

### 主要函数

#### 转移（Transfer）

要在 T-REX 上完成一次转移，需满足以下条件：

- 发送方需要持有足够的可用余额（总余额 - 已冻结代币，如有）。
- 接收方需要在身份注册表中被列入白名单并通过验证（其 [`ONCHAINID`](https://github.com/onchain-id/solidity) 具备必要的声明）。
- 发送方钱包不得被冻结。
- 接收方钱包不得被冻结。
- 转移需符合在 `Compliance` 智能合约中定义的所有合规规则（`canTransfer` 需要返回 `TRUE`）。

以下是 `transfer` 函数实现示例：
```solidity
function transfer(address _to, uint256 _amount) public override whenNotPaused returns (bool) {
        require(!frozen[_to] && !frozen[msg.sender], 'wallet is frozen');
        require(_amount <= balanceOf(msg.sender).sub(frozenTokens[msg.sender]), 'Insufficient Balance');
        if (tokenIdentityRegistry.isVerified(_to) && tokenCompliance.canTransfer(msg.sender, _to, _amount)) {
            tokenCompliance.transferred(msg.sender, _to, _amount);
            _transfer(msg.sender, _to, _amount);
            return true;
        }
        revert('Transfer not possible');
    }
```

`transferFrom` 函数的工作方式相同，而 `mint` 与 `forcedTransfer` 函数只要求接收方在身份注册表中被列入白名单并通过验证（它们绕过合规规则）。`burn` 函数则绕过所有资格检查。

#### isVerified

`isVerified` 函数从 `transfer`、`transferFrom`、`mint` 与 `forcedTransfer` 等转移函数内部调用，指示 `Identity Registry` 检查接收方是否为有效投资者，即其钱包地址是否在该代币的 `Identity Registry` 中，并且其 `ONCHAINID` 合约是否包含 `Claim Topics Registry` 所要求的声明主题，且这些声明由 `Trusted Issuers Registry` 中的授权声明发行者签名。
若全部要求得到满足，`isVerified` 返回 `TRUE`，否则返回 `FALSE`。该函数的实现可在 [T-REX 仓库](https://github.com/TokenySolutions/T-REX) 中找到。

#### canTransfer

`canTransfer` 函数也从转移函数内部调用。该函数检查转移是否符合代币适用的全局合规规则。与仅检查投资者持有与接收代币资格的 `isVerified` 相反，`canTransfer` 关注全局合规规则，例如：在必须满足固定最大投资者数量（也可限定每个国家的投资者数量上限）的情况下，检查转移是否合规；或检查是否符合每位投资者的最大代币数量限制等。
若所有要求满足，`canTransfer` 返回 `TRUE`，否则返回 `FALSE` 并阻止该转移发生。该函数的实现可在 [T-REX 仓库](https://github.com/TokenySolutions/T-REX) 中找到。

#### 其他函数

关于 ERC-3643 的其他函数的描述可在 `interfaces` 文件夹中找到。ERC-3643 智能合约套件的实现可见 [T-REX 仓库](https://github.com/TokenySolutions/T-REX)。

### 代币接口

ERC-3643 许可型代币基于标准 ERC-20 结构，但增加了一些函数以确保安全代币交易的合规性。`transfer` 与 `transferFrom` 以条件方式实现，仅当交易有效时才允许进行。许可型代币仅允许转移给已验证的交易对手，以避免代币被持有在不合格/未授权投资者的钱包/ONCHAINID 中。ERC-3643 还支持在投资者丢失其钱包私钥时找回安全代币。为增强透明度，会在链上维护代币找回的历史记录。ERC-3643 代币实现了大量附加函数，使所有者或其代理可以管理供给、转移规则、锁定期，以及安全代币管理可能需要的一切。
函数的详细说明可参见[接口文件夹](https://github.com/TokenySolutions/EIP3643/tree/main/interfaces)。

```solidity
interface IERC3643 is IERC20 {

   // 事件
    event UpdatedTokenInformation(string _newName, string _newSymbol, uint8 _newDecimals, string _newVersion, address _newOnchainID);
    event IdentityRegistryAdded(address indexed _identityRegistry);
    event ComplianceAdded(address indexed _compliance);
    event RecoverySuccess(address _lostWallet, address _newWallet, address _investorOnchainID);
    event AddressFrozen(address indexed _userAddress, bool indexed _isFrozen, address indexed _owner);
    event TokensFrozen(address indexed _userAddress, uint256 _amount);
    event TokensUnfrozen(address indexed _userAddress, uint256 _amount);
    event Paused(address _userAddress);
    event Unpaused(address _userAddress);


    // 函数
    // 读取器（getters）
    function decimals() external view returns (uint8);
    function name() external view returns (string memory);
    function onchainID() external view returns (address);
    function symbol() external view returns (string memory);
    function version() external view returns (string memory);
    function identityRegistry() external view returns (IIdentityRegistry);
    function compliance() external view returns (ICompliance);
    function paused() external view returns (bool);
    function isFrozen(address _userAddress) external view returns (bool);
    function getFrozenTokens(address _userAddress) external view returns (uint256);

    // 设置器（setters）
    function setName(string calldata _name) external;
    function setSymbol(string calldata _symbol) external;
    function setOnchainID(address _onchainID) external;
    function pause() external;
    function unpause() external;
    function setAddressFrozen(address _userAddress, bool _freeze) external;
    function freezePartialTokens(address _userAddress, uint256 _amount) external;
    function unfreezePartialTokens(address _userAddress, uint256 _amount) external;
    function setIdentityRegistry(address _identityRegistry) external;
    function setCompliance(address _compliance) external;

    // 转移动作
    function forcedTransfer(address _from, address _to, uint256 _amount) external returns (bool);
    function mint(address _to, uint256 _amount) external;
    function burn(address _userAddress, uint256 _amount) external;
    function recoveryAddress(address _lostWallet, address _newWallet, address _investorOnchainID) external returns (bool);

    // 批量函数
    function batchTransfer(address[] calldata _toList, uint256[] calldata _amounts) external;
    function batchForcedTransfer(address[] calldata _fromList, address[] calldata _toList, uint256[] calldata _amounts) external;
    function batchMint(address[] calldata _toList, uint256[] calldata _amounts) external;
    function batchBurn(address[] calldata _userAddresses, uint256[] calldata _amounts) external;
    function batchSetAddressFrozen(address[] calldata _userAddresses, bool[] calldata _freeze) external;
    function batchFreezePartialTokens(address[] calldata _userAddresses, uint256[] calldata _amounts) external;
    function batchUnfreezePartialTokens(address[] calldata _userAddresses, uint256[] calldata _amounts) external;

    // 角色设定
    function transferOwnershipOnTokenContract(address _newOwner) external;
    function addAgentOnTokenContract(address _agent) external;
    function removeAgentOnTokenContract(address _agent) external;
}

```

### 身份注册表接口

该身份注册表与一个存储模块相连，后者包含与安全代币相关的授权投资者动态白名单。身份注册表负责建立钱包地址、[ONCHAINID](https://tokeny.com/onchainid/) 与国家代码之间的映射，该国家代码按照 [ISO-3166 标准](https://www.iso.org/iso-3166-country-codes.html) 设置。它还包含一个 `isVerified()` 函数，根据用户 ONCHAINID 中声明的有效性（满足安全代币的要求）返回状态。身份注册表由代理钱包管理，即只有代理可在注册表中添加或移除身份（注意：身份注册表上的代理角色由所有者设置，因此若所有者希望全部自行控制，可将自己设置为代理）。每个安全代币都有其特定的身份注册表。
函数的详细说明可见[接口文件夹](https://github.com/TokenySolutions/EIP3643/tree/main/interfaces)。

注意，[`IClaimIssuer`](https://github.com/onchain-id/solidity/blob/master/contracts/interface/IClaimIssuer.sol) 与 [`IIdentity`](https://github.com/onchain-id/solidity/blob/master/contracts/interface/IIdentity.sol) 接口来自 [ONCHAINID](https://github.com/onchain-id/solidity)。

```solidity
interface IIdentityRegistry {


    // 事件
    event ClaimTopicsRegistrySet(address indexed claimTopicsRegistry);
    event IdentityStorageSet(address indexed identityStorage);
    event TrustedIssuersRegistrySet(address indexed trustedIssuersRegistry);
    event IdentityRegistered(address indexed investorAddress, IIdentity indexed identity);
    event IdentityRemoved(address indexed investorAddress, IIdentity indexed identity);
    event IdentityUpdated(IIdentity indexed oldIdentity, IIdentity indexed newIdentity);
    event CountryUpdated(address indexed investorAddress, uint16 indexed country);


    // 函数
    // 身份注册表读取器
    function identityStorage() external view returns (IIdentityRegistryStorage);
    function issuersRegistry() external view returns (ITrustedIssuersRegistry);
    function topicsRegistry() external view returns (IClaimTopicsRegistry);

    // 身份注册表设置器
    function setIdentityRegistryStorage(address _identityRegistryStorage) external;
    function setClaimTopicsRegistry(address _claimTopicsRegistry) external;
    function setTrustedIssuersRegistry(address _trustedIssuersRegistry) external;

    // 注册表操作
    function registerIdentity(address _userAddress, IIdentity _identity, uint16 _country) external;
    function deleteIdentity(address _userAddress) external;
    function updateCountry(address _userAddress, uint16 _country) external;
    function updateIdentity(address _userAddress, IIdentity _identity) external;
    function batchRegisterIdentity(address[] calldata _userAddresses, IIdentity[] calldata _identities, uint16[] calldata _countries) external;

    // 注册表查询
    function contains(address _userAddress) external view returns (bool);
    function isVerified(address _userAddress) external view returns (bool);
    function identity(address _userAddress) external view returns (IIdentity);
    function investorCountry(address _userAddress) external view returns (uint16);

    // 角色设置
    function transferOwnershipOnIdentityRegistryContract(address _newOwner) external;
    function addAgentOnIdentityRegistryContract(address _agent) external;
    function removeAgentOnIdentityRegistryContract(address _agent) external;
}
```

### 身份注册表存储接口

身份注册表存储合约存储与所关联安全代币相关的所有授权投资者的身份地址，即所有已通过适当 KYC 与资格检查、被授权持有代币的投资者身份。身份注册表存储可绑定到一个或多个身份注册表合约。其目标是将身份注册表函数与规范从其存储中分离，这样就可以为每个代币保留一个独立的身份注册表（拥有其自身的受信发行者注册表与声明主题注册表），同时共享用于 `isVerifed()`（注：原文拼写）函数的白名单，以在转移交易中检查接收方的资格。
函数的详细说明可见[接口文件夹](https://github.com/TokenySolutions/EIP3643/tree/main/interfaces)。

```solidity
interface IIdentityRegistryStorage {

    // 事件
    event IdentityStored(address indexed investorAddress, IIdentity indexed identity);
    event IdentityUnstored(address indexed investorAddress, IIdentity indexed identity);
    event IdentityModified(IIdentity indexed oldIdentity, IIdentity indexed newIdentity);
    event CountryModified(address indexed investorAddress, uint16 indexed country);
    event IdentityRegistryBound(address indexed identityRegistry);
    event IdentityRegistryUnbound(address indexed identityRegistry);

    // 函数
    // 存储相关函数
    function storedIdentity(address _userAddress) external view returns (IIdentity);
    function storedInvestorCountry(address _userAddress) external view returns (uint16);
    function addIdentityToStorage(address _userAddress, IIdentity _identity, uint16 _country) external;
    function removeIdentityFromStorage(address _userAddress) external;
    function modifyStoredInvestorCountry(address _userAddress, uint16 _country) external;
    function modifyStoredIdentity(address _userAddress, IIdentity _identity) external;

    // 角色设置
    function transferOwnershipOnIdentityRegistryStorage(address _newOwner) external;
    function bindIdentityRegistry(address _identityRegistry) external;
    function unbindIdentityRegistry(address _identityRegistry) external;

    // 已绑定身份注册表的读取器
    function linkedIdentityRegistries() external view returns (address[] memory);
}

```

### 合规模块接口

合规模块用于设置发行本身的规则，并确保这些规则在代币的整个生命周期中得到遵循。例如，合规模块会定义每个国家的最大投资者数量、每位投资者的最大代币数量、代币可流通的国家（基于身份注册表中的国家代码）。合规模块是“量身定制”的合约，根据法律要求并遵照代币发行方的需求来实现。在每笔交易中由代币触发，如交易符合规则则返回 `TRUE`，否则返回 `FALSE`。
函数的详细说明可见[接口文件夹](https://github.com/TokenySolutions/EIP3643/tree/main/interfaces)。

```solidity
interface ICompliance {

    // 事件
    event TokenAgentAdded(address _agentAddress);
    event TokenAgentRemoved(address _agentAddress);
    event TokenBound(address _token);
    event TokenUnbound(address _token);

    // 函数
    // 合规模块初始化
    function addTokenAgent(address _agentAddress) external;
    function removeTokenAgent(address _agentAddress) external;
    function bindToken(address _token) external;
    function unbindToken(address _token) external;

    // 合规模块参数检查
    function isTokenAgent(address _agentAddress) external view returns (bool);
    function isTokenBound(address _token) external view returns (bool);

    // 合规检查与状态更新
    function canTransfer(address _from, address _to, uint256 _amount) external view returns (bool);
    function transferred(address _from, address _to, uint256 _amount) external;
    function created(address _to, uint256 _amount) external;
    function destroyed(address _from, uint256 _amount) external;

    // 所有权设置
    function transferOwnershipOnComplianceContract(address newOwner) external;
}
```

### 受信发行者注册表接口

受信发行者注册表存储针对某一安全代币的所有受信任声明发行者的合约地址（[ONCHAINID](https://tokeny.com/onchainid/)）。代币所有者（投资者）的 [ONCHAINID](https://tokeny.com/onchainid/) 必须具有由该注册表中存储的声明发行者签名的声明，方可持有代币。该合约的所有权属于代币发行方，允许其根据需求管理该注册表。
函数的详细说明可见[接口文件夹](https://github.com/TokenySolutions/EIP3643/tree/main/interfaces)。

```solidity
interface ITrustedIssuersRegistry {

    // 事件
    event TrustedIssuerAdded(IClaimIssuer indexed trustedIssuer, uint[] claimTopics);
    event TrustedIssuerRemoved(IClaimIssuer indexed trustedIssuer);
    event ClaimTopicsUpdated(IClaimIssuer indexed trustedIssuer, uint[] claimTopics);

    // 函数
    // 设置器
    function addTrustedIssuer(IClaimIssuer _trustedIssuer, uint[] calldata _claimTopics) external;
    function removeTrustedIssuer(IClaimIssuer _trustedIssuer) external;
    function updateIssuerClaimTopics(IClaimIssuer _trustedIssuer, uint[] calldata _claimTopics) external;

    // 读取器
    function getTrustedIssuers() external view returns (IClaimIssuer[] memory);
    function isTrustedIssuer(address _issuer) external view returns(bool);
    function getTrustedIssuerClaimTopics(IClaimIssuer _trustedIssuer) external view returns(uint[] memory);
    function hasClaimTopic(address _issuer, uint _claimTopic) external view returns(bool);

    // 角色设置
    function transferOwnershipOnIssuersRegistryContract(address _newOwner) external;
}
```

### 声明主题注册表接口

声明主题注册表存储该安全代币的所有受信声明主题。代币所有者的 [ONCHAINID](https://tokeny.com/onchainid/) 必须包含该合约中存储的声明主题之一。该合约的所有权属于代币发行方，允许其根据需求管理该注册表。
函数的详细说明可见[接口文件夹](https://github.com/TokenySolutions/EIP3643/tree/main/interfaces)。

```solidity
interface IClaimTopicsRegistry {

    // 事件
    event ClaimTopicAdded(uint256 indexed claimTopic);
    event ClaimTopicRemoved(uint256 indexed claimTopic);

    // 函数
    // 设置器
    function addClaimTopic(uint256 _claimTopic) external;
    function removeClaimTopic(uint256 _claimTopic) external;

    // 读取器
    function getClaimTopics() external view returns (uint256[] memory);

    // 角色设置
    function transferOwnershipOnClaimTopicsRegistryContract(address _newOwner) external;
}
```

## 测试用例

该标准已在 Tokeny 的 [T-REX 仓库](https://github.com/TokenySolutions/T-REX) 中实现并通过完整覆盖的测试。

## 安全注意事项

该智能合约套件已由外部独立公司审计。审计结果可见[此文档](https://tokeny.com/wp-content/uploads/2020/05/Tokeny-Solutions_T-REX-v3_Smart-Contract-Audit-Report_Kapersky.pdf)。

## 版权

通过 [CC0](../LICENSE.md) 放弃版权及相关权利。

